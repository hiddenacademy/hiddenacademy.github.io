---
layout: post
title: "linux"
date: 2025-06-26
categories: tutorial
image: /assets/images/ctf-platform-screenshot.png
comments: 3
---


---

# ✅ **VERSION FINALE — TEXTE CORRIGÉ, STRUCTURÉ, PRO**

# Introduction

Le **shell** est un programme qui fournit à l’utilisateur une interface pour saisir des instructions et afficher le résultat sous forme textuelle (Bash, Zsh, cmd, PowerShell, etc.).

La plupart des systèmes Linux utilisent **Bash** (*Bourne Again Shell*) comme shell par défaut, une version améliorée du shell historique **sh** d’Unix.

Il existe toutefois plusieurs autres shells, notamment :

* **Bash** (Bourne-again shell)
* **csh / tcsh** (C shell)
* **ksh** (Korn shell)
* **zsh** (Z shell)

Sous Linux, **Bash** reste le plus courant. C’est également celui utilisé dans ce cours.

---

# L’Invite de Commande (Prompt)

Lorsqu’on utilise un shell interactif, les commandes sont saisies à une **invite de commande** (*prompt*), qui ressemble généralement à ceci :

```
username@hostname[~]$ 
```

Exemples :

Invite d’un utilisateur normal :

```
lordp@kali:~$ 
```

Invite du super-utilisateur root :

```
root@computer:~# 
```

### Explication :

* **username** : nom de l’utilisateur exécutant la commande
* **hostname** : nom de la machine
* **~** : répertoire personnel de l’utilisateur (`/home/user`)
* **$** : shell d’un utilisateur normal
* **#** : shell exécuté par root

Tant que nous n’avons pas besoin de privilèges particuliers, nous utiliserons une invite **non privilégiée** (`$`).

---

# Structure d’une Commande

Format général :

```
commande [options] [arguments]
```

Exemple :

```
ls -l /home
```

### Décomposition :

* **commande** : programme exécuté → `ls`
* **option(s)** : modifie le comportement → `-l` (affichage long)
* **argument(s)** : données sur lesquelles agit la commande → `/home`

Les options existent souvent en version courte (`-l`) et longue (`--format=long`), et peuvent se combiner :

```
ls -al
ls -a -l
ls -all     # identique à --format=long
```

---

# Obtenir de l’Aide

### 1. `--help`

La plupart des commandes affichent un résumé :

```
ls --help
```

### 2. La commande `man`

Affiche la documentation détaillée :

```
man pwd
```

### 3. La commande `info`

Une autre source d’information :

```
info pwd
```

---

# Fichiers & Répertoires

Un **fichier** est une collection de données (textes, binaires, images…).
Un **répertoire** est un fichier spécial permettant d’organiser d’autres fichiers.

Le système de fichiers Linux repose sur une **arborescence**, où chaque répertoire peut en contenir d’autres. La ligne de commande offre un contrôle rapide et efficace sur ces éléments.

---

# Commandes Essentielles

## Créer un Répertoire : `mkdir`

```
mkdir [OPTIONS]... DIRECTORY...
```

Créer un répertoire :

```
mkdir test
```

Créer des répertoires parents automatiquement :

```
mkdir -p dir1/dir2/dir3
```

---

# Supprimer des Fichiers & Répertoires

### `rm` — supprimer fichiers ou dossiers

```
rm [OPTIONS] FILE...
```

### `rmdir` — supprimer un répertoire *vide*

```
rmdir emptydir
```

> `rmdir` **ne peut supprimer que les répertoires vides**.

### Suppression récursive (danger !)

Supprimer un dossier + tout son contenu :

```
rm -r dossier
```

Suppression forcée (sans confirmation) :

```
rm -rf dossier
```

⚠️ **Attention :**
`rm -rf /` = *mode autodestruction* (à ne **jamais** exécuter).

---

# Créer un Fichier : `touch`

```
touch fichier.txt
```

* S’il n’existe pas → créé vide
* S’il existe → met à jour son horodatage

Créer un fichier avec du contenu :

```
echo "Hello" > file.txt
```

---

# Déplacer & Renommer : `mv`

```
mv source destination
```

Exemple :

```
mv file22 file2
```

Empêcher l’écrasement involontaire :

```
mv -i file1 file2
```

---

# Copier : `cp`

Copier un fichier :

```
cp source dest
```

Copier plusieurs fichiers dans un répertoire :

```
cp file1 file2 dir/
```

Copie récursive (répertoires) :

```
cp -r dir1 dir2
```

---

# Bonnes Pratiques de Nommage en Linux

* Pas d’accents : pas de é, à, ï, ç
* Pas d’espaces (utiliser `_` ou `-`)
* Pas de caractères spéciaux (`% $ ! & ...`)
* Noms courts mais explicites
* Sensible à la casse : `file` ≠ `File`

---

# Lire un Fichier : `cat`

```
cat fichier
```

### Espaces dans les noms :

```
cat "note pour le cours"
```

### Noms commençant par `-`

Fichier nommé `-` :

```
cat ./-
```

---

# Lister un Répertoire : `ls`

```
ls
ls -l         # format long
ls -a         # fichiers cachés
ls -la        # combine les deux
ls -tr        # trier par date, inversé
```

---

# Chemins Linux : Absolus vs Relatifs

* **Chemin absolu** : commence toujours par `/`
  Ex : `/home/user/Documents`

* **Chemin relatif** : dépend du répertoire courant

  * `.` → répertoire actuel
  * `..` → parent

Afficher le chemin absolu :

```
pwd
```

---

# Arborescence Linux — Répertoires Importants

| Répertoire    | Rôle                        |
| ------------- | --------------------------- |
| `/`           | Racine du système           |
| `/root`       | Home de root                |
| `/home`       | Homes des utilisateurs      |
| `/bin`        | Commandes essentielles      |
| `/sbin`       | Outils système              |
| `/etc`        | Fichiers de configuration   |
| `/usr`        | Programmes et bibliothèques |
| `/var`        | Logs, fichiers variables    |
| `/dev`        | Périphériques               |
| `/boot`       | Démarrage du système        |
| `/mnt`        | Points de montage           |
| `/lib`        | Bibliothèques système       |
| `/lost+found` | Récupération de fichiers    |

---

# Navigation : `cd`

```
cd            # aller au home
cd /path      # chemin absolu
cd ..         # parent
cd -          # précédent
```

---

# Localiser des Fichiers

## `locate` — rapide (via base de données)

```
locate filename
```

Supporte les jokers (`*`, `?`) et expressions régulières.

## `find` — recherche réelle dans l’arborescence

```
find . -name ".bashrc"
```

Exemples utiles :

Fichiers exécutables :

```
find . -executable
```

Fichiers non exécutables :

```
find . ! -executable
```

Fichiers d’une taille précise :

```
find . -size 1033c
```

Fichiers d’un utilisateur :

```
find . -user username
```

Exécution sur chaque fichier :

```
find . -type f -exec file '{}' \; | grep ASCII
```

---

# Droits d’Accès (Permissions)

Chaque fichier possède :

1. **Propriétaire** (user)
2. **Groupe** (group)
3. **Autres** (others)

Et trois types de permissions :

* **r** = read (lecture)
* **w** = write (écriture)
* **x** = execute (exécution)

---

# Voir les Permissions : `ls -l`

Exemple :

```
drwxr-xr-x
```

Décomposition :

* `d` : répertoire (ou `-` fichier, `l` lien, etc.)
* `rwx` : droits du propriétaire
* `r-x` : droits du groupe
* `r-x` : droits des autres

---

# Changer Propriétaire et Groupe

## `chown` — changer propriétaire

```
sudo chown user fichier
```

## `chgrp` — changer groupe

```
sudo chgrp groupe fichier
```

## `chown` (propriétaire + groupe)

```
sudo chown user:group fichier
```

---

# Modifier les Droits : `chmod`

## Syntaxe symbolique

```
chmod u+x fichier     # ajoute exécution au propriétaire
chmod g-w fichier     # retire écriture au groupe
chmod a+r fichier     # lecture pour tous
```

Combinaisons :

```
chmod u+rwx,g+rx-w,o+r-wx fichier
```

## Syntaxe octale

| Droits | Valeur |
| ------ | ------ |
| r      | 4      |
| w      | 2      |
| x      | 1      |

Exemples :

```
chmod 644 fichier   # rw-r--r--
chmod 755 fichier   # rwxr-xr-x
chmod 600 fichier   # rw-------
```

---

```
