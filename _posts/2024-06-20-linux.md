---
layout: post
title: "linux"
date: 2025-06-26
categories: tutorial
image: /assets/images/ctf-platform-screenshot.png
comments: 3
---

# Introduction

Le **shell** est un programme qui fournit à l'utilisateur d'un ordinateur une interface pour saisir des instructions dans le système et afficher la sortie en texte (Bash, Zsh, cmd et PowerShell, par exemple). 

Tous systèmes Linux utilisent un programme appelé **Bash** (Bourne Again Shell) comme programme shell pour interagir avec le système d'exploitation. Bash est une version améliorée de **sh**, le programme shell original des systèmes Unix.

En plus de **bash** il existe également d'autres shells notamment, mais sans s'y limiter :

- **Bourne-again shell** (Bash)
- **C shell** (csh ou tcsh, the enhanced csh)
- **Korn shell** (ksh)
- **Z shell** (zsh)

Sous Linux, le plus courant est le shell Bash. C'est également celui qui sera utilisé ici dans ce cours.

## L'Invite de Commande

Lorsqu'on utilise un shell interactif, l'utilisateur entre des commandes à une invite de commande (prompt). Pour chaque distribution Linux, l'invite par défaut peut être un peu différente, mais elle suit généralement cette structure :

```
user@hostname[~]$ current_directory shell_type
```

Sur Ubuntu ou Debian GNU/Linux, l'invite pour un utilisateur régulier ressemblera probablement à ceci :

```
lordp@kali[~]$  
```

L'invite du super-utilisateur ressemblera à ceci :

```
root@computer[~]#  
```

### Explication de chaque élément :

- **username** : Nom de l'utilisateur qui exécute le shell
- **hostname** : Nom de l'hôte sur lequel tourne le shell. Il existe également une commande hostname, avec laquelle vous pouvez afficher ou définir le nom d'hôte du système.
- **current_directory** : Le répertoire dans lequel le shell se trouve actuellement. Un `~` signifie que le shell se trouve dans le répertoire personnel de l'utilisateur courant.
- **shell_type** : 
  - `$` indique que le shell est exécuté par un utilisateur régulier
  - `#` indique que le shell est exécuté par le super-utilisateur root

Quand nous n'avons pas besoin de privilèges spéciaux, nous utiliserons une invite non privilégiée dans les exemples suivants.

## Structure de la Ligne de Commande

```
commande [option(s)/parametre(s)…] [argument(s)...]
```

Prenons la commande suivante comme exemple :

```
lordp@kali[~]$ ls -l /home
```

### Explication de chaque composante :

- **commande** : Programme que l'utilisateur va exécuter - `ls` dans l'exemple ci-dessus
- **option(s)/parametre(s)** : Un "interrupteur" qui modifie le comportement de la commande d'une manière ou d'une autre, comme `-l` dans l'exemple ci-dessus. Les options sont accessibles sous une forme courte et une forme longue. Par exemple, `-l` est identique à `--format=long`

Il est possible de combiner plusieurs options, pour la forme courte les lettres peuvent généralement être collées. Par exemple, les commandes suivantes font toutes la même chose :

```
lordp@kali[~]$ ls -al
lordp@kali[~]$ ls -a -l
lordp@kali[~]$ ls -all → --format=long
```

- **argument(s)** : Les données supplémentaires requises par le programme, comme un nom de fichier ou un chemin d'accès, comme `/home` dans l'exemple ci-dessus

La seule partie obligatoire de cette structure est la commande elle-même. En général, tous les autres éléments sont facultatifs, mais un programme peut exiger que certaines options, paramètres ou arguments soient spécifiés.

## Obtenir de l'Aide sur les Commandes

**Bon à savoir** : La plupart des commandes affichent un bref aperçu des commandes disponibles lorsqu'elles sont exécutées avec le paramètre `--help`.

Un autre moyen d'en savoir plus sur les commandes Linux est :

### La commande `man`

Donne plus d'informations sur une commande, comme les informations supplémentaires nécessaires ainsi que les indicateurs possibles.

**NAME**
```
man - est le programme de visualisation des pages de manuel
```

**SYNOPSIS**
```
man [options de man] [[section] page ...] …
```

**Exemple** : `man pwd`

### La commande `info`

**NAME**
```
info - 
```

**SYNOPSIS**
```
info [options de man] [[section] page ...] …
```

**Exemple** : `info pwd`

## Fichiers et Répertoires

Un **fichier** est une collection de données avec un nom et un ensemble d'attributs. Si, par exemple, vous deviez transférer certaines photos de votre téléphone à un ordinateur et leur donner des noms descriptifs, vous auriez alors un tas de fichiers d'images sur votre ordinateur. Ces fichiers ont des attributs tels que l'heure du dernier accès au fichier ou de sa dernière modification.

Un **répertoire** est un type de fichier spécial utilisé pour organiser les fichiers. Une bonne façon de concevoir les répertoires est de les comparer aux dossiers utilisés pour organiser les documents dans une armoire à dossiers. Contrairement aux dossiers papier, vous pouvez facilement placer des répertoires à l'intérieur d'autres répertoires.

La ligne de commande est le moyen le plus efficace de gérer des fichiers sur un système Linux. Le shell et les outils en ligne de commande ont des caractéristiques qui rendent l'utilisation de la ligne de commande plus rapide et plus facile qu'un gestionnaire de fichiers graphique.

Le système de fichiers Linux est similaire aux systèmes de fichiers d'autres systèmes d'exploitation car il contient des fichiers et des répertoires. Les fichiers contiennent des données telles que du texte lisible par l'homme, des programmes exécutables ou des données binaires utilisées par l'ordinateur. Les répertoires sont utilisés pour créer une organisation au sein du système de fichiers. Les répertoires peuvent contenir des fichiers et d'autres répertoires.

## Commandes de Gestion des Fichiers

### Création de Répertoires : `mkdir`

**NAME**
```
mkdir - créer des répertoires
```

**SYNOPSIS**
```
mkdir [OPTION]... [Directory]…
```

**DESCRIPTION**
```
Créez le(s) RÉPERTOIRE(s), s'ils n'existent pas déjà.
```

**Bon à savoir** : `mkdir`, par défaut, ne crée pas de répertoire à l'intérieur d'un répertoire qui n'existe pas. L'option `-p` ou `--parents` indique à `mkdir` de créer des répertoires parents s'ils n'existent pas.

### Suppression de Fichiers et de Répertoires

La commande `rm` peut supprimer des fichiers et des répertoires, tandis que la commande `rmdir` ne peut supprimer que des répertoires.

#### `rm` - remove files or directories

**NAME**
```
rm - 
```

**SYNOPSIS**
```
rm [OPTION]...[ FILE]…
```

**DESCRIPTION**
```
C
```

#### `rmdir` - remove empty directories

**NAME**
```
rmdir - supprime un répertoire vide
```

**SYNOPSIS**
```
rmdir [OPTION]...[ DIRECTORY]…
```

**DESCRIPTION**
```
C supprimer un répertoire qui n'est pas vide
```

Par défaut, `rmdir` ne peut supprimer que des répertoires vides, c'est pourquoi nous devons utiliser `rm` pour supprimer un fichier régulier.

La suppression d'un grand nombre de fichiers ou de profondes structures de répertoires comportant de nombreux sous-répertoires peut sembler fastidieuse, mais elle est en fait très facile. Par défaut, `rm` ne fonctionne que sur les fichiers ordinaires. L'option `-r` est utilisée pour passer outre ce comportement.

**Attention**, `rm -r` est une commande extrêmement dangereuse ! Je m'explique : Lorsque vous utilisez l'option `-r`, `rm` ne supprime pas seulement les répertoires, mais tout ce qui se trouve dans ce répertoire, y compris les sous-répertoires et leur contenu.

**NAME** → commande de la mort qui tue
```
rm -rf / → SHINRA TEINSEI
```

### Création de Fichiers

En règle générale, les fichiers seront créés par les programmes qui travaillent avec les données stockées dans les fichiers. Un fichier vide peut être créé à l'aide de la commande `touch`.

#### `touch` - change file timestamps

**NAME**
```
touch - peut créer un fichier vide
```

**SYNOPSIS**
```
touch [OPTION]... FILE...
```

Si vous exécutez la commande `touch` sur un fichier existant, le contenu du fichier ne sera pas modifié, mais l'horodatage de modification des fichiers sera mis à jour.

Vous pouvez utiliser la commande `echo` avec `>` pour créer des fichiers texte simples.

### Déplacement et Renommage : `mv`

Les fichiers sont déplacés et renommés avec la commande `mv`.

#### `mv` - move (rename) files

**NAME**
```
mv - [OPTION]... [-T] SOURCE DEST
```

**SYNOPSIS**
```
mv [OPTION]... -t DIRECTORY SOURCE…
```

**DESCRIPTION**
```
Renommez SOURCE vers DEST ou déplacez la ou les SOURCE(s) vers RÉPERTOIRE.
```

**Bon à savoir** : Supposons que `file22` est une faute de frappe et qu'il devrait être `file2`. Corrigez-la avec la commande `mv`. Lorsque vous renommez un fichier, le premier argument est le nom actuel, le second est le nouveau nom.

Faites attention à la commande `mv`. Si vous renommez un fichier en lui donnant le nom d'un fichier existant, il l'écrasera c'est pourquoi Utilisez l'option `-i` pour que `mv` vous alerte si vous êtes sur le point d'écraser un fichier existant est une bonne idée.

### Copie : `cp`

La commande `cp` est utilisée pour copier des fichiers et des répertoires.

#### `cp` - copy files and directories

**NAME**
```
cp - [OPTION]... [-T] SOURCE DEST
```

**SYNOPSIS**
```
mv [OPTION]... -t DIRECTORY SOURCE…
cp [OPTION]... SOURCE... DIRECTORY
cp [OPTION]... -t DIRECTORY SOURCE...
```

**DESCRIPTION**
```
Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.
```

**Bon à savoir** : Si le dernier argument est un répertoire, `cp` créera une copie des arguments précédents à l'intérieur de ce répertoire. Comme pour la commande `mv`, plusieurs fichiers peuvent être spécifiés en même temps, à condition que la cible soit un répertoire.

Lorsque les deux opérandes de `cp` sont des fichiers et que les deux fichiers existent, `cp` écrase le second fichier avec une copie du premier fichier.

La commande `cp` ne fonctionne par défaut que sur des fichiers individuels. Pour copier un répertoire, vous utilisez l'option `-r`. Gardez à l'esprit que l'option `-r` fera que `cp` copie également le contenu du répertoire que vous copiez.

## Bonnes Pratiques pour le Nommage

Un nom de fichier ou de dossier se doit d'être unique, court, sans espace et significatif. Il faut donc, pour chaque documents ou répertoire, trouver le meilleur compromis entre une désignation courte et une désignation explicite permettant de traduire le contenu qui lui est associé.

### Règles sous Linux :

- Les noms de fichiers ne doivent pas contenir de signes diacritiques : pas d'accent ni de tréma (é à ï), pas de cédille (ç)
- Ne pas utiliser de caractères spéciaux (sauf underscore « _ » ) : % $ ! & / \ : ; « » % & # @ etc.
- Il n'est pas conventionnel et va à l'encontre des meilleures pratiques d'inclure des espaces dans un nom de fichier (ainsi que dans un nom de répertoire). Au lieu de cela, vous devez utiliser un trait de soulignement (_) ou un tiret (-)

### Lecture de fichiers : `cat`

La commande `cat` lit les fichiers de manière séquentielle et les écrit sur la sortie standard ou, en d'autres termes, imprime le contenu des fichiers sur la console.

#### `cat` - concatenate files and print on the standard output

**NAME**
```
cat - concaténer des fichiers et imprimer sur la sortie standard
```

**SYNOPSIS**
```
cat [OPTION]... [FILE]…
```

**Exemple** : `cat nomdufichier`

**NB** : Contrairement à Microsoft Windows, les noms de fichiers et de répertoires sur les systèmes Linux sont sensibles à la casse. Cela signifie que les noms `fichier` et `Fichier` sont deux fichiers différents.

## Problèmes Courants avec les Noms de Fichiers

### Le symbole `-`

**Bon à savoir** : le symbole `-` est spécial sous Linux. Il n'est donc pas recommandé de commencer un nom de fichier par ce symbole. Car Nous l'utilisons pour ajouter une options spécifiques à une commande. Pour cette raison, les fichiers avec ce symbole comme premier caractère ne peuvent pas être simplement référencés comme d'autres fichiers.

L'utilisation de la commande `cat -` ne renvoie rien. Ainsi, au lieu d'écrire simplement, `-` nous ajoutons le chemin et écrivons `(./-)` et la commande fonctionne comme il se doit :

```
lordp@kali[~]$ cat ./-
```

### Les espaces dans les noms

**Bon à savoir** : Dans une commande, les espaces indiquent un nouvel ajout à la commande. Par exemple, nous si utilisons la commande `cat` (qui peut prendre plusieurs noms de fichiers pour afficher leur texte) sur un fichier contenant des espaces dans son nom comme par exemple → `note pour le cour` ←.

Si nous essayons de lire ce fichier avec la commande `cat` comme ceci :

```
lordp@kali[~]$ cat note pour le cour
```

Nous obtiendrons l'erreur suivante :

```
lordp@kali[~]$ cat : note : No such file or directory
lordp@kali[~]$ cat : pour : No such file or directory
lordp@kali[~]$ cat : le : No such file or directory
lordp@kali[~]$ cat : cour : No such file or directory
```

Si vous rencontrez un fichier ou un répertoire avec un ou des espaces, vous devez indiquer que les mots appartiennent ensemble à un même nom de fichier. Cela peut être fait avec des guillemets (simples ou doubles) (`''`) ou (`""`) comme suit :

```
lordp@kali[~]$ cat "note pour le cour"
```

## Liste des Fichiers : `ls`

Le contenu du répertoire actuel est listé avec la commande `ls` :

#### `ls` - list directory contents

**NAME**
```
ls - Liste les fichiers du dossier actuel (si le dossier n'est pas spécifié)
```

**SYNOPSIS**
```
ls [OPTION]... [FILE]…
```

**DESCRIPTION**
```
Répertoriez les informations sur les Fichier du (le répertoire actuel par défaut). Trier les entrées par ordre alphabétique si aucun des éléments -cftuvSUX ou --sort n'est spécifié.
```

**Exemple** : `ls -l`

Deux indicateurs facultatifs qui doivent être connus pour cette commande sont `-l`, qui imprime les fichiers dans un format de liste longue (informations supplémentaires sur un fichier) et `-a`, qui affiche également les fichiers cachés.

Les options `-t` et `-r` sont particulièrement pratiques pour lister le contenu d'un répertoire avec `ls`. Elles permettent de trier la sortie par temps (`-t`) et d'inverser l'ordre de tri (`-r`). Dans ce cas, les fichiers les plus récents se trouveront en bas de la sortie.

## Les Répertoires Systèmes et l'Arborescence sous Linux

Sous linux La référence à une ressource (fichier ou répertoire) s'appelle un chemin d'accès (en anglais : path). Dans ce chemin, sous Linux, les noms des répertoires et éventuel ceux des fichiers sont séparés par un slash (`/`).

Le chemin de la commande peut être un **chemin absolu** (chemin depuis le répertoire racine `/`) ou un **chemin relatif** (chemin depuis le répertoire de travail actuel).

- Le **chemin absolu** d'un fichier est défini par la liste des dossiers à parcourir pour atteindre ce fichier depuis la racine de l'arborescence.
- Le **chemin relatif** d'un fichier défini sa position par rapport à un dossier donné de l'arborescence. On utilise pour cela la notation `..` pour désigner le dossier parent d'un dossier donné.

**Bon à savoir** : La commande `pwd` affiche toujours un chemin absolu. Cela signifie que le chemin contient chaque Les chemins absolus commencent toujours par un `/`.

Si vous allez dans le répertoire `/` (appelé plus couramment Répertoire Racine), vous y trouverez toute une liste de répertoire sans comprendre leur signification.

Voici une représentation schématique de l'arborescence des répertoires sous LINUX.

## Les Répertoires Linux et leurs Contenu

### `/` - Racine
Le répertoire `/` est en quelque sorte la racine du système de fichiers de Linux. Il renferme les principaux fichiers, tous les autres répertoires sont des sous-répertoires de la racine `/`

### `/root` - Home de root
Le répertoire root constitue le répertoire maison de l'utilisateur root (administrateur du système).

### `/bin` - Binaires essentiels
Dans le répertoire bin, enregistre les programmes nécessaires à l'exécution des principales commandes telles que celles permettant de réaliser les diverses opérations sur les fichiers ou les répertoires.

### `/boot` - Démarrage
Le répertoire boot contient toutes les données utiles au démarrage de l'ordinateur. Parmi elles, on trouve les informations qu'exploite LILO pour pouvoir lancer le système d'exploitation de votre choix.

### `/dev` - Périphériques
Le répertoire dev enregistre les fichiers des périphériques (différents ports série, parallèle ...)

### `/etc` - Configuration
Ce répertoire conserve les fichiers de configuration linux. Il est subdivisé en plusieurs sous-répertoires, par exemple `/etc/passwd`, dans lequel se trouvent tous les noms et les mots de passe des utilisateurs.

### `/home` - Utilisateurs
Il s'agit du répertoire contenant les sous-répertoires maisons des différents utilisateurs du système, par exemple `/home/toto` est crée. Il correspond au répertoire maison de l'utilisateur toto.

### `/lib` - Bibliothèques
Dans ce répertoire, Linux enregistre les bibliothèques du système, qui correspondent aux dll de Windows (cas de la carte graphique). Celles-ci sont partagées par tous les programmes présents sur votre ordinateur, elles génèrent ainsi un gain de mémoire puisqu'il est inutile de les installer pour chacun de ces programmes.

### `/lost+found` - Fichiers perdus
Linux crée ce répertoire sur chaque support de données, avec son système de fichiers propre, ext2 ou ext3. Si l'entrée du répertoire d'un fichier a été supprimée ou n'est plus lisible, alors que le fichier lui-même est toujours disponible dans le système de fichiers, Linux peut le rendre de nouveau accessible à l'aide des données de ce répertoire.

### `/mnt` - Points de montage
Permet de monter ou démonter un CD-ROM, DVD-ROM ou une clé USB.

### `/sbin` - Binaires système
Comme le répertoire bin, sbin accueille différents programmes. Mais pour sa part, il s'agit uniquement de programmes ayant trait à l'administration du système, ne peut s'exécuter avec l'administrateur root.

### `/usr` - Applications utilisateur
Le répertoire usr et sous-répertoires accueillent des programmes nécessaires au démarrage du système. Les sous-répertoires remplissent des tâches très variées.

### `/var` - Fichiers variables
Ce répertoire contient les fichiers "variables", qui sont autrement dits en permanente mutation, il peut s'agir, par exemple des fichiers de la file d'attente d'impression (`/var/spool/lpd`).

## Navigation dans le Système de Fichiers

La navigation dans Linux se fait principalement avec la commande `cd`. De l'anglais change directory. En fonction de votre répertoire de travail actuel, cette commande requiert soit le chemin d'accès complet, soit le nom du répertoire. L'exécution de cette commande sans option vous conduira au dossier personnel.

#### `cd` - change the working directory

**NAME**
```
ls - change le répertoire de travail
```

**SYNOPSIS**
```
cd [-L|-P] [directory]
```

**Bon à savoir** : 
- `.` Indique l'emplacement actuel
- `..` Indique le répertoire parent

### `pwd` - print name of current/working directory

**NAME**
```
pwd - imprimer le nom du répertoire actuel/de travail
```

**SYNOPSIS**
```
pwd [OPTION]…
```

**DESCRIPTION**
```
Imprime le nom de fichier complet du répertoire de travail actuel.
```

Cette commande est une méthode pour voir quel est le répertoire de travail actuel. Une alternative peut être le symbole à gauche à côté du nom d'utilisateur. `[~]` Le tilde est un caractère spécial qui représente le répertoire personnel de l'utilisateur ici il indique le répertoire de travail actuel comme répertoire personnel de l'utilisateur.

## Localisation des Fichiers

Un système Linux est construit à partir de nombreux répertoires et fichiers. Linux dispose de nombreux outils pour localiser un fichier particulier au sein d'un système. Le plus rapide est la commande `locate`. `locate` recherche dans une base de données et affiche ensuite chaque nom qui contient la chaîne de caractères donnée en argument:

#### `locate` - find files by name, quickly

**NAME**
```
locate - concaténer des fichiers et imprimer sur la sortie standard
```

**SYNOPSIS**
```
locate [OPTION]... Pattern…
```

**Exemple** : `locate nomdufichier`

**Bon à savoir** : La commande `locate` permet d'utiliser des jokers et des expressions régulières, de sorte que la chaîne de caractères recherchée ne doit pas nécessairement être équivalente au nom complet du fichier souhaité.

## La Commande `find`

`find` est un autre outil très populaire qui est utilisé pour la recherche de fichiers.

#### `find` - search for files in a directory hierarchy

**NAME**
```
find - recherche de fichiers dans une hiérarchie de répertoires
```

**SYNOPSIS**
```
find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]
```

**Exemple** : `find . -name nomdufichier`

**Bon à savoir** : Cette commande a une approche différente de celle de la commande `locate`. La commande `find` recherche récursivement dans une arborescence de répertoires, y compris ses sous-répertoires. Find effectue une telle recherche à chaque appel, elle ne maintient pas de base de données comme `locate`.

Tout comme `locate`, `find` supporte également les jokers et les expressions régulières. `find` nécessite au moins le chemin où il doit chercher comme argument. En outre, des expressions peuvent être ajoutées pour fournir des critères de filtrage des fichiers à afficher. Un exemple est l'expression `-name`, qui recherche des fichiers avec un nom spécifique.

La commande `find` permet de recherche des fichier exécutable avec l'option `-executable` et non exécutable avec l'option `!-executable` :

```
find . ! -executable
```

### Quelques options intéressantes de la commande `find`

- Pour consulte la taille d'un fichier en octets
  ```
  find -size <bytes>
  ```

- Permet de consulte uniquement les fichiers
  ```
  find . -type f
  ```

- Fichiers lisibles
  ```
  find -readable
  ```

Nous utilisons `-exec file '{}' \;`, pour exécuter la `file` commande et obtenir le type de données du fichier. Après cela, nous devons simplement filtrer à nouveau la sortie pour le type de fichier « ASCII ».

```
find - -type f -size 1033c ! -executable -exec file '{}' \; | grep ASCII
```

La commande `-user` permet de chercher un ou des fichier appartenant a un utilisateur spécifique :

```
-user <username>
```

Et à un groupe spécifique avec l'option :

```
-groupe <groupname>
```

## Droits d'Accès sous Linux : Gérer les Accès aux Fichiers

Les **droits d'accès** définissent la possession d'un fichier ou d'un répertoire à un utilisateur et à un groupe d'utilisateurs. Ils gèrent aussi quelles actions les utilisateurs ont le droit d'effectuer sur les fichiers, selon qu'ils sont propriétaire du fichier, membre du groupe propriétaire du fichier ou ni l'un ni l'autre. La possession et la gestion des permissions associées s'effectue individuellement avec chaque fichier.

## Les Propriétaires

Par la propriété d'un fichier, on désigne à quel utilisateur appartient le fichier, qui le possède. À partir de cette possession (ou non), il sera ensuite possible de définir des permissions d'accès sur le fichier.

La possession d'un fichier se définit sur trois catégories :

1. **L'utilisateur propriétaire** du fichier (`u`). Il s'agit généralement du créateur du fichier. (Prenez note qu'un fichier créé par une commande exécutée à l'aide de `sudo` appartiendra à l'utilisateur `root` ; vous serez potentiellement amené à devoir changer le propriétaire de ce fichier pour pouvoir vous en servir avec votre propre compte utilisateur.)

2. **Le groupe propriétaire** du fichier (`g`). Si un utilisateur est membre d'un certain groupe qui possède la propriété d'un fichier, l'utilisateur aura aussi certaines permissions particulières sur ce fichier.

3. **Les autres**, `other`, le reste du monde (`o`). Bref, tout un chacun n'étant ni propriétaire du fichier, ni membre du groupe propriétaire du fichier.

## Les Permissions

Les permissions désignent ce que les diverses catégories d'utilisateurs (propriétaire d'un fichier, membres du groupe propriétaire d'un fichier et le reste du monde) ont l'autorisation d'effectuer sur un fichier donné. Par exemple, une catégorie d'utilisateurs peut avoir accès en lecture et écriture à un fichier, alors qu'une autre catégorie a accès en lecture seulement à ce même fichier.

Les permissions se définissent sur trois niveaux :

1. **La lecture** d'un fichier : cette permission est nécessaire pour pouvoir accéder au contenu d'un fichier (écouter une piste audio, visionner un film, lire un texte, lister le contenu (ls) naviguer à l'intérieur d'un répertoire…). Cette permission est notée `r` (pour *read*, lire).

2. **L'écriture** dans un fichier : cette permission est nécessaire pour pouvoir apporter des modifications à un fichier (corriger un texte et enregistrer les changements.). Cette permission est notée `w` (pour *write*, écrire).

3. **L'exécution** d'un fichier : cette permission est nécessaire particulièrement pour les logiciels, afin qu'ils puissent être exécutés. Cette permission est notée `x` (pour *execute*, exécuter). Pour un répertoire, la permission "x" permet d'en faire le répertoire courant (cd).

Pour chacune des trois catégories d'utilisateurs (propriétaire, membres du groupe propriétaire et reste du monde) sont définies ces trois permissions :

- Le propriétaire dispose ou non de la permission de lecture, d'écriture et d'exécution sur un fichier ;
- Le membre du groupe propriétaire dispose ou non de la permission de lecture, d'écriture et d'exécution sur un fichier ;
- Tous les autres utilisateurs disposent ou non de la permission de lecture, d'écriture et d'exécution sur un fichier.

Les droits sont affichés par une série de 9 caractères, associés 3 par 3 (`rwx rwx rwx`) qui définissent les droits des 3 identités (u, g et o).

## En Ligne de Commande

Les droits des fichiers d'un répertoire peuvent être affichés par la commande :

```
ls -l
```

Les droits d'accès apparaissent alors comme une liste de 10 symboles :

```
drwxr-xr-x
```

Le premier symbole peut être `-`, `d`, soit `l`, entres autres. Il indique la nature du fichier :

- `-` : fichier classique
- `d` : *directory* : répertoire
- `l` : *link* : lien symbolique
- `c` : *character* : périphérique de type caractère
- `b` : *block* : périphérique de type bloc
- `p` : *pipe* : tube, tuyau ou file (d'attente)
- `s` : *socket*

Suivent ensuite 3 groupes de 3 symboles chacun, indiquant si le fichier (ou répertoire) est autorisé en lecture, écriture ou exécution. Les 3 groupes correspondent, dans cet ordre, aux droits du propriétaire, du groupe puis du reste des utilisateurs.

Dans le paragraphe introductif, vous aurez remarqué des lettres en gras dans les termes anglais. Ce sont ces lettres qui sont utilisées pour symboliser lesdites permissions. Si la permission n'est pas accordée, la lettre en question est remplacé par « - ». Si l'on reprend les lettres données pour lecture/écriture/exécution (read/write/execute), nous obtenons : `rwx`.

## Explication par l'Exemple

Reprenons l'exemple théorique précédent :

```
propriétaire            groupe                      autres
drwxr            -xr              -x
```

Il se traduit de la manière suivante :

- `d` : c'est un répertoire.
- `rwx` pour le 1er groupe de 3 symboles : son propriétaire peut lire, écrire et exécuter.
- `r-x` pour le 2e groupe de 3 symboles : le groupe peut uniquement lire et exécuter le fichier, sans pouvoir le modifier.
- `r-x` pour le 3ème groupe de 3 symboles : le reste du monde peut uniquement lire et exécuter le fichier, sans pouvoir le modifier.

## En Ligne de Commande

Un fichier a un **propriétaire** et un **groupe**. Nous pouvons les changer.

### `chown` pour changer le propriétaire

La commande `chown` (*change owner* ⇒ changer le propriétaire) permet de changer le propriétaire du fichier. Seuls le super-utilisateur ou le propriétaire actuel d'un fichier peut utiliser `chown`. La commande s'utilise de la façon suivante :

```
sudo chown toto fichier1
```

Le fichier `fichier1` appartient maintenant à l'utilisateur `toto`.

### `chgrp`, pour changer le groupe

La commande `chgrp` (pour *change group*) permet de changer le groupe auquel appartient le fichier. Tous les membres de ce groupe seront concernés par les permissions du groupe de la 2ème série de `rwx`. Encore une fois, seuls le super-utilisateur ou le propriétaire actuel d'un fichier peut utiliser `chgrp` (un membre du groupe ne peut pas changer le groupe propriétaire). La commande s'utilise de la façon suivante :

```
sudo chgrp mesPotes fichier2
```

Le fichier `fichier2` appartient maintenant au groupe `mesPotes`. Tous les membres du groupe `mesPotes` auront accès à ce fichier selon les permissions du groupe.

Quand l'utilisateur actuel n'est pas le propriétaire actuel du fichier, il sera nécessaire de faire précéder la commande par `sudo`, puisqu'elle devra être effectuée avec les droits d'administration.

### `chown`, pour changer simultanément le propriétaire et le groupe

Pour changer à la fois le propriétaire et le groupe propriétaire, une syntaxe particulière de la commande `chown` peut être utilisée. Encore une fois, seuls le super-utilisateur ou le propriétaire actuel d'un fichier peut utiliser `chown` (un membre du groupe ne peut pas effectuer de changement de propriété). La commande s'utilise de la façon suivante :

```
chown nouveau_propriétaire:nouveau_groupe_propriétaire nom_du.fichier
```

Quand l'utilisateur actuel n'est pas le propriétaire actuel du fichier, il sera nécessaire de faire précéder la commande par `sudo`, puisqu'elle devra être effectuée avec les droits d'administration.

Imaginons le même fichier `foo.txt` possédé par `utilisateur1` et appartenant au groupe propriétaire `groupe1`. Le propriétaire doit devenir `utilisateur2` et la propriété de groupe de ce fichier doit passer au groupe `groupe2`. En étant connecté au compte `utilisateur1`, l'exécution de cette commande effectuera l'opération demandée :

```
chown utilisateur2:groupe2 foo.txt
```

## `chmod`, pour changer les droits

L'outil `chmod` (*change mode*, changer les permissions) permet de modifier les permissions sur un fichier. Il peut s'employer de deux façons : soit en précisant les permissions de manière octale, à l'aide de chiffres ; soit en ajoutant ou en retirant des permissions à une ou plusieurs catégories d'utilisateurs à l'aide des symboles `r w et x`, que nous avons présentés plus haut. Nous préférerons présenter cette seconde façon ("ajout ou retrait de permissions à l'aide des symboles"), car elle est probablement plus intuitive pour les néophytes. Sachez seulement que les deux méthodes sont équivalentes, c'est-à-dire qu'elles affectent toutes deux les permissions de la même manière.

## En Gérant Chaque Droit Séparément

De cette façon, on va choisir :

1. **À qui s'applique le changement**
   - `u` (*user*, utilisateur) représente la catégorie "propriétaire" ;
   - `g` (*group*, groupe) représente la catégorie "groupe propriétaire" ;
   - `o` (*others*, autres) représente la catégorie "reste du monde" ;
   - `a` (*all*, tous) représente l'ensemble des trois catégories.

2. **La modification que l'on veut faire**
   - `+` : ajouter
   - `-` : supprimer
   - `=` : affectation

3. **Le droit que l'on veut modifier**
   - `r` : *read* ⇒ lecture
   - `w` : *write* ⇒ écriture
   - `x` : *execute* ⇒ exécution
   - `X` : *eXecute* ⇒ exécution, concerne uniquement les répertoires (qu'ils aient déjà une autorisation d'exécution ou pas) et les fichiers qui ont déjà une autorisation d'exécution pour l'une des catégories d'utilisateurs. Nous allons voir plus bas dans la partie des traitements récursifs l'intérêt du X.

### Exemples :

```
chmod o-w fichier3
```

enlèvera le droit d'écriture pour les autres.

```
chmod a+x
```

ajoutera le droit d'exécution à tout le monde.

On peut aussi combiner plusieurs actions en même temps :

- On ajoute la permission de lecture, d'écriture et d'exécution sur le fichier `fichier3` pour le propriétaire ;
- On ajoute la permission de lecture et d'exécution au groupe propriétaire, on retire la permission d'écriture ;
- On ajoute la permission de lecture aux autres, on retire la permission d'écriture et d'exécution.

```
chmod u+rwx,g+rx-w,o+r-wx fichier3
```

## En Octal

En **octal**, chaque "groupement" de droits (pour user, group et other) sera représenté par un chiffre et à chaque droit correspond une valeur :

- r (read) = 4
- w (write) = 2
- x (execute) = 1
- - = 0

Ce qui permet de faire toutes les combinaisons :

- 0 : `- - -` (aucun droit)
- 1 : `- - x` (exécution)
- 2 : `- w -` (écriture)
- 3 : `- w x` (écriture et exécution)
- 4 : `r - -` (lecture seule)
- 5 : `r - x` (lecture et exécution)
- 6 : `r w -` (lecture et écriture)
- 7 : `r w x` (lecture, écriture et exécution)

<style>
.post-content {
  font-family: 'Inter', sans-serif;
  line-height: 1.7;
  color: #333;
}

.post-content h1 {
  color: #0066ff;
  border-bottom: 3px solid #00c6ff;
  padding-bottom: 10px;
  margin-bottom: 20px;
}

.post-content h2 {
  color: #0066ff;
  margin-top: 30px;
  margin-bottom: 15px;
}

.post-content h3 {
  color: #0066ff;
  margin-top: 25px;
  margin-bottom: 10px;
}

.post-content code {
  background: #f8fafc;
  padding: 2px 6px;
  border-radius: 4px;
  border: 1px solid #e2e8f0;
  font-family: 'Courier New', monospace;
  color: #0066ff;
}

.post-content pre {
  background: #0f172a;
  color: #e2e8f0;
  padding: 20px;
  border-radius: 8px;
  overflow-x: auto;
  margin: 20px 0;
  border-left: 4px solid #0066ff;
  font-family: 'Courier New', monospace;
  line-height: 1.5;
}

.post-content ul, .post-content ol {
  margin: 15px 0;
  padding-left: 30px;
}

.post-content li {
  margin-bottom: 8px;
}

.post-content blockquote {
  border-left: 4px solid #00c6ff;
  padding: 15px 20px;
  margin: 20px 0;
  background: #f0f7ff;
  border-radius: 0 8px 8px 0;
  font-style: italic;
}

.post-content table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

.post-content th {
  background: #0066ff;
  color: white;
  padding: 12px;
  text-align: left;
}

.post-content td {
  padding: 10px 12px;
  border: 1px solid #e2e8f0;
}

.post-content tr:nth-child(even) {
  background: #f8fafc;
}
</style>
```
